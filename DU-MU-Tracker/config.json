{"slots":{"0":{"name":"bank","type":{"events":[],"methods":[]}},"1":{"name":"screen","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"\nlocal read_only = false --export 0 for full, 1 for read only\nlocal capture = false --export set to true to clear database and set values programmatically below\nlocal data_on_screen = false --export places the content of the databanks on the screen\n\nlocal mode = MODE_FULL\nif (read_only) then\n    mode = MODE_READ\nend\n\nif (capture) then\n   bank.clear()\nend\n\nif (screen.getState() == 0) then\n    screen.activate()\nend\n\nentries = Entries:new(nil)\nentries:setMode(mode)\n\nif (entries:hasContentIn(bank)) then\n    entries:loadFrom(bank)\nelse\n    --optionally programatically add your own entries here by uncommenting the next few lines  \n    --entries:update(0,'An Entry First',getTimestampFromStr('0m'),'100')\n    --entries:update(0,'Another Entry',getTimestampFromStr('2d12h'),'100','65')\n    --entries:update(0,'Third Entry',getTimestampFromStr('23h1m'),'75','65')\n    --entries:saveTo(bank)\nend\nlocal screenRender = getRenderScript()\nif (data_on_screen) then\n    screenRender = \"--[\"..entries:serializeData()..\"]\"..screenRender\nend    \nscreen.setRenderScript(screenRender)\n\n--entries:print()\nentries:refresh()\n\nunit.setTimer('heartbeat',1)\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"local action = screen.getScriptOutput()\nif (action == nil or action == '') then return end\n--system.print(\"button:\"..action)\nscreen.clearScriptOutput()\nlocal sort = false\n--handle actions from screen\nif (startsWith(action,\"done\")) then\n    local val = split(action,'_')\n    local pos = tonumber(val[2])\n    entries:quickUpdate(pos)\n    sort = true\nend    \nif (action == \"prev\") then\n    entries:setPrevPage()\nend    \nif (action == \"next\") then\n    entries:setNextPage()\nend\nif (action == \"edit\") then\n    entries:setMode(MODE_EDIT)\nelseif (startsWith(action,\"edit\")) then\n    local val = split(action,'_')\n    local pos = tonumber(val[2])\n    local entryPos,entry = entries:getEntryClicked(pos)\n    entries.editpos = entryPos\n    system.print(\"Type 'edit <time since calibration>,<current efficiency>,<threshold>'\")\n    system.print(\"Example with current values:\")\n    local threshold = entry:getThreshold()\n    local time = getTimeAsStr((system.getTime()-entry.timestamp)/3600)\n    local origCalib = entry:getOrigCalib()\n    system.print(\"edit \" .. time ..\",\".. origCalib ..\",\"..threshold)\n    sort = false\nend\nif (action == \"delete\") then\n    entries:setMode(MODE_DELT)\nelseif (startsWith(action,\"delt\")) then\n    local val = split(action,'_')\n    local pos = tonumber(val[2])\n    local entryPos,entry = entries:getEntryClicked(pos)\n    if (entry ~= nil) then\n        system.print(\"Are you sure you wish to delete \"..entry.name..\"? [y/n]\")\n        entries.delpos = entryPos\n    end\n    sort = false\nend\nif (action == \"add\") then\n    system.print(\"Type 'add <name>,<time since calibration>,<current efficiency>,<threshold>'\")\n    system.print(\"Examples:\")\n    system.print(\"add An Entry\")\n    system.print(\"add Another Entry,3d4h45m\")\n    system.print(\"add Yet Another Entry,45m,67\")\n    system.print(\"add The Last Entry,45m,100,40\")\n    system.print(\"Type 'addall <name>,<time since calibration>,<current efficiency>,<threshold>;<name>,<time since calibration>,<current efficiency>,<threshold>;<name>,<time since calibration>,<current efficiency>,<threshold>'\")\n    system.print(\"to add multiple at once.  addall requires all except the threshold.\")\nend\nif (action == \"normal\") then\n    entries:setMode(MODE_NORM)\nend\n\nentries:refresh(action,sort)","filter":{"args":[{"value":"heartbeat"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"if (screen.getState() == 1) then\n    screen.deactivate()\nend","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"2"},{"code":"--Version 1.05\n\njson = require('dkjson')\n\nGLOBAL_THRESHOLD = 70 --export\n\nSTATUS_OK = 0\nSTATUS_WARN = 1\nSTATUS_ALERT = 2\n\nMODE_READ = 0\nMODE_FULL = 1\nMODE_EDIT = 2\nMODE_DELT = 3\n\nLINESEP = ';'\nSEP = ','\n\nGRACE_PERIOD = 259200\n\nfunction compare(a,b)\n    local remta = a.remTimeVal or 0\n    local remtb = b.remTimeVal or 0\n    if remta == 0 and remtb == 0 then\n        return a.timestamp < b.timestamp\n    end    \n    return remta < remtb\nend\n\nfunction startsWith(text, prefix)\n    return text:find(prefix, 1, true) == 1\nend\n\nfunction split(txt,sep)\n    local result = {}\n    for w in string.gmatch(txt,\"([^\"..sep..\"]+)\") do \n        result[#result+1] = w\n    end\n    return result\nend\n\nfunction stripChar(txt,char)\n    local result = ''\n    for w in string.gmatch(txt,\"([^\"..char..\"]+)\") do \n        result = result..w\n    end\n    return result\nend    \n\nfunction stripEdgeWhitespace(txt)\n    return string.gsub(txt, '^%s*(.-)%s*$', '%1')\nend\n\nfunction isInCooldown(timestamp)\n    if (timestamp == nil or timestamp == 0) then\n        return 0\n    end    \n    local current = system.getTime()\n    local diff = current - timestamp\n    if (diff < 86400) then return 1 end\n    return 0\nend    \n\nfunction calcCalib(origCalib, timestamp)\n    if (timestamp == nil or timestamp == 0) then\n        return 0\n    end    \n    local current = system.getTime()\n    local diff = current - timestamp\n    --grace period has no change.\n    diff = diff - GRACE_PERIOD\n    if diff < 0 then\n        diff = 0\n    end    \n    local calib = origCalib\n    if calib == nil or calib == 0 then\n        calib = 100\n    end\n    --reduce by 0.625 per remaining hour\n    local decrease = (diff/3600)*0.625\n    calib = calib - decrease\n    if (calib < 0) then calib = 0 end\n    return calib\nend  \n\nfunction calcRemainingTime(timestamp,calib,threshold)\n    if (timestamp == nil or timestamp == 0) then\n        return 0\n    end\n    local percdiff = calib - threshold\n    if (percdiff < 0) then\n        return 0\n    end\n    local result = 0\n    local current = system.getTime()\n    local tdiff = current - timestamp\n    if (tdiff < GRACE_PERIOD) then\n        result = (GRACE_PERIOD - tdiff)/3600\n    end    \n    result = result + (percdiff/0.625) --hours\n    return result\nend    \n\nfunction calcRemainingCooldownTime(timestamp) --in hours\n    if (timestamp == nil or timestamp == 0) then\n        return 0\n    end\n    local current = system.getTime()\n    local tdiff = current - timestamp\n    if (tdiff < 86400) then\n        return (86400 - tdiff)/3600\n    end\n    return 0\nend    \n\nfunction getTimeAsStr(time) -- time in hours\n    local result = ''\n    if (time <=0) then return ' ' end\n    local days = math.floor(time/24)\n    if days > 0 then\n        time = time - (days*24)\n        result = tostring(days) .. 'd'\n    end\n    local hours = math.floor(time)\n    if hours > 0 then\n        time = time - hours\n        result = result .. tostring(hours) .. 'h'\n    end\n    local minutes = math.floor(time*60)\n    result = result .. tostring(minutes) .. 'm'\n    return result\nend    \n\nfunction getTimestampFromStr(timeStr)\n    local result = system.getTime()\n    local lowerStr = timeStr:lower()\n    local d = string.match(lowerStr, '(%d+)d')\n    local h = string.match(lowerStr, '(%d+)h')\n    local m = string.match(lowerStr, '(%d+)m')\n    if d == nil then d = '0' end\n    if h == nil then h = '0' end\n    if m == nil then m = '0' end\n    d = tonumber(d,10)\n    h = tonumber(h,10)\n    m = tonumber(m,10)\n    if d < 0 then d = 0 end\n    if h < 0 then h = 0 end\n    if m < 0 then m = 0 end\n    result = result - d*24*60*60 - h*60*60 - m*60 \n    return result\nend    \n\nfunction formatPerc(perc)\n    if perc == nil then perc = 0 end\n    local result = tostring(math.floor(perc))..'%'\n    return result\nend    \n\nfunction ensureNotEmpty(txt)\n    if (txt == nil or txt == '') then\n        return ' '\n    end\n    return txt\nend    \n\nEntry = {}\n\nfunction Entry:new(o)\n   o = o or {}\n   o.name = ''\n   o.timestamp = ''\n   setmetatable(o, self)\n   self.__index = self\n   return o\nend\n\nfunction Entry:setInfo(name,timestamp,origCalib,threshold) \n  self.name = stripEdgeWhitespace(name) \n  self.timestamp = math.floor(tonumber(timestamp))\n  if (origCalib == nil) then\n      origCalib = '100'\n  end\n  self.origCalib = tonumber(origCalib,10)  \n  if threshold ~= nil then \n      self.threshold = tonumber(threshold,10)\n      if self.threshold == GLOBAL_THRESHOLD then\n          self.threshold = nil\n      end\n  end\n    \nend\n\nfunction Entry:save(db)\n  --system.print(\"Saving...\"..self.pos .. \" \" .. self:serializeData())  \n  db.setStringValue(tostring(self.pos), self:serializeData())\nend\n\nfunction Entry:print()\n    system.print(self:serializeData())\n    --system.print(self:serialize())\nend    \n\nfunction Entry:serializeData()\n    local result = self.name\n    result = result .. SEP .. tostring(self.timestamp)\n    result = result .. SEP .. tostring(self.origCalib)\n    if (self.threshold ~= nil) then\n        result = result .. SEP .. tostring(self.threshold)\n    end    \n    return result\nend    \n\nfunction Entry:serialize()\n    self:calcStatus()\n    local result = tostring(self.status)\n    result = result .. SEP .. ensureNotEmpty(self.name)\n    result = result .. SEP .. formatPerc(self.calib)\n    result = result .. SEP .. ensureNotEmpty(self.remainingTime)\n    result = result .. SEP .. formatPerc(self:getThreshold())\n    result = result .. SEP .. tostring(self.inCooldown)\n    return result\nend\n\nfunction Entry:calcStatus()\n    self.status = STATUS_OK\n    self.calib = calcCalib(self.origCalib, self.timestamp)\n    self.remTimeVal = calcRemainingTime(self.timestamp, self.calib, self:getThreshold())\n    self.inCooldown = isInCooldown(self.timestamp)\n    if (self.inCooldown and self.remTimeVal == 0) then\n        self.remTimeVal = calcRemainingCooldownTime(self.timestamp)\n    end\n    self.remainingTime = getTimeAsStr(self.remTimeVal)\n    if (self.remTimeVal <= 0) then\n        self.status = STATUS_ALERT\n    elseif (self.remTimeVal <= 24) then\n        self.status = STATUS_WARN\n    end   \n       \nend    \n\nfunction Entry:getThreshold()\n    local result = GLOBAL_THRESHOLD\n    if (self.threshold ~= nil) then\n        result = self.threshold\n    end\n    return result    \nend\n\nfunction Entry:getOrigCalib()\n    local result = 100\n    if (self.origCalib ~= nil) then\n        result = self.origCalib\n    end\n    return result    \nend \n\nEntries = {}\n\nfunction Entries:new(o)\n   o = o or {}\n   o.entries = {}\n   o.pageNum = 1 \n   setmetatable(o, self)\n   self.__index = self\n   return o\nend\n\nfunction Entries:saveTo(db)\n  system.print('Saving to DB')  \n  for i=1,#self.entries do\n    self.entries[i]:save(db)\n  end\nend\n\nfunction Entries:serializeData()\n  local result = ''\n  for i=1,#self.entries do\n    if (i == 1) then \n        result = self.entries[i]:serializeData()\n    else        \n        result = result .. LINESEP .. self.entries[i]:serializeData()\n    end        \n  end\n  return result\nend\n\nfunction Entries:hasContentIn(db)\n    return (db.getNbKeys() > 0)\nend\n\nfunction Entries:loadFrom(db)\n    system.print('Loading from DB '..db.getNbKeys())\n    local keys = json.decode(db.getKeys())\n    for _,k in pairs(keys) do\n        local val = db.getStringValue(k)\n        local splitval = split(val,SEP)\n        self:addNew(tonumber(k),splitval[1],splitval[2],splitval[3],splitval[4])\n    end    \nend\n\nfunction Entries:addNew(pos, name, timestamp, origCalib, threshold)    \n  local entry = Entry:new()  \n  entry:setInfo(name,timestamp,origCalib,threshold)\n  entry.pos = tonumber(pos)  \n  self.entries[pos] = entry\n  return entry \nend\n\nfunction Entries:updateEntriesByName(input)\n    local inputEntries = split(input,LINESEP)\n    for _,inputEntry in ipairs(inputEntries) do\n        local parsedInput = split(inputEntry,SEP)    \n        local inEntry = Entry:new()\n        inEntry:setInfo(parsedInput[1],parsedInput[2],parsedInput[3],parsedInput[4])\n        --check for same name\n        local pos = self:updateByName(inEntry)\n        if pos == 0 then\n            --name not found so just add it\n            system.print(\"Adding \"..inEntry.name)\n            self:update(0,parsedInput[1],parsedInput[2],parsedInput[3],parsedInput[4])\n        end    \n    end\nend\n\nfunction Entries:updateByName(inEntry)\n    for i,entry in ipairs(self.entries) do\n        if (entry.name == inEntry.name) then\n            system.print(\"Updating \"..inEntry.name)\n            entry:setInfo(inEntry.name,\n                tostring(inEntry.timestamp),\n                tostring(inEntry.origCalib),\n                tostring(inEntry.threshold))\n            return i\n        end\n    end\n    return 0\nend\n\nfunction Entries:print()\n    for _,entry in ipairs(self.entries) do\n        entry:print()\n    end\nend\n\nfunction Entries:update(pos, name, timestamp, origCalib, threshold)\n  if threshold == GLOBAL_THRESHOLD then\n     threshold = nil\n  end      \n  local entry = self.entries[pos]\n  --system.print(\"updating...\"..entry.name..\" at \"..pos)\n  if entry == nil then\n     if (pos == 0 or pos == nil or pos > #self.entries) then\n         pos = #self.entries+1\n     end       \n     entry = self:addNew(pos,name,timestamp,origCalib,threshold)  \n  else   \n     entry:setInfo(name,timestamp,origCalib,threshold)   \n  end\n  return entry\nend\n\nfunction Entries:quickUpdate(pos)\n   local entryPos,entry = self:getEntryClicked(pos)\n   if entry == nil then\n     return\n   end\n   entry.timestamp = system.getTime()\n   local newCalib = entry.calib + 35\n   if (newCalib > 100) then newCalib = 100 end \n   entry.origCalib = math.floor(newCalib+0.5)\n   entry:save(bank)\nend    \n\nfunction Entries:setPrevPage()\n    local page = self.pageNum\n    page = page - 1\n    if (page < 1) then page = 1 end\n    self.pageNum = page\n    return page\nend\n\nfunction Entries:setNextPage()\n    local page = self.pageNum\n    page = page + 1\n    local maxPage = math.floor((#self.entries-1)/10)+1\n    if (page > maxPage) then page = maxPage end\n    self.pageNum = page\n    return page\nend\n\nfunction Entries:serialize(action)\n    local pageNum = self.pageNum\n    local maxPage = math.floor((#self.entries-1)/10)+1\n    local posStart = ((pageNum-1)*10)+1\n    local posEnd = posStart+9\n    if posStart < 1 then\n        posStart = 1\n    end\n    if posEnd > #self.entries then\n        posEnd = #self.entries\n    end\n    --system.print('Getting pos '..posStart..' to '..posEnd)\n    local result = ''\n    if (action == nil or action == '') then action = ' ' end\n    --header\n    result = tostring(system.getTime()) \n    result = result .. SEP .. tostring(pageNum)\n    result = result .. SEP .. tostring(maxPage)\n    result = result .. SEP .. tostring(action)\n    result = result .. SEP .. tostring(self.mode)\n    if (posStart > posEnd) then\n        return result\n    end\n    for i=posStart,posEnd do\n        local entry = self.entries[i]\n        local line = entry:serialize()\n        result = result .. LINESEP .. line   \n    end\n    --system.print(\"screen input str \"..result)\n    return result\nend  \n\nfunction Entries:sort()\n    for _,entry in ipairs(self.entries) do\n        entry:calcStatus()\n    end\n    table.sort(self.entries,compare)\nend\n\nfunction Entries:refresh(action,sort)\n    action = action or ''\n    sort = sort or true\n    if sort then self:sort() end\n    screen.setScriptInput(entries:serialize(action))\nend\n\nfunction Entries:setMode(mode)\n    self.mode = mode or MODE_FULL\nend   \n\nfunction Entries:getEntryClicked(pos)\n    local entryPos = ((self.pageNum-1)*10)+pos\n    local entry = self.entries[entryPos]\n    return entryPos,entry\nend\n\nfunction getRenderScript()\n    return [[ \n--start of render script\nMODE_READ = 0\nMODE_FULL = 1\nMODE_EDIT = 2\nMODE_DELT = 3\n\nfunction split(txt,sep)\n    local result = {}\n    for w in string.gmatch(txt,\"([^\"..sep..\"]+)\") do \n        result[#result+1] = w\n    end\n    return result\nend\n\nfunction findAction(actionTbl)\n    local cx,cy = getCursor() \n    local result = '';\n    for action,square in pairs(actionTbl) do\n        if (cx > square[1] and cx < square[3] and cy > square[2] and cy < square[4]) then\n            return action\n        end    \n    end\n    return result\nend    \n\nlocal input = getInput()\nlocal tb = {}\nlocal newTimestamp = 0\nlocal pageNum = 1\nlocal maxPage = 1\nlocal newAction = ''\nlocal mode = MODE_READ\nif (input ~= nil or input ~= '') then\n    local temp = split(input,';')\n    for i,k in ipairs(temp) do\n        if (i==1) then --header\n            local line = split(k,',')\n            newTimestamp = tonumber(line[1])\n            pageNum = tonumber(line[2])\n            maxPage = tonumber(line[3])\n            newAction = line[4]\n            mode = tonumber(line[5])\n        else    \n            local line = split(k,',')\n            table.insert(tb,line)\n        end    \n    end    \nend  \n\nlocal actionTbl = {}\nlocal tbsize = #tb-1\nlocal maxx,maxy = getResolution()\nlocal xpad = maxx/100\nlocal ypad = maxy/100\nlocal boxh = maxy/13\nif (xpad < 1) then xpad = 1 end\nif (ypad < 1) then ypad = 1 end\n--background\nlocal pic = loadImage(\"gui/screen_unit/img/BG_propaganda_poster.png\")\nlocal layer = createLayer()\naddImage(layer, pic, 0, 0, maxx, maxy)\n--pretty layer\nlayer = createLayer()\nfor i=0,tbsize do\n    local offset = i*(boxh+ypad)\n    local status = tonumber(tb[i+1][1])\n    if status == 2 then\n        setDefaultFillColor(layer, Shape_Polygon, 155/255, 55/255 , 55/255, 100/255)\n    elseif status == 1 then\n        setDefaultFillColor(layer, Shape_Polygon, 155/255, 155/255 , 55/255, 100/255)\n    else\n        setDefaultFillColor(layer, Shape_Polygon, 55/255, 55/255 , 55/255, 100/255)\n    end    \n    addQuad(layer, xpad, ypad+offset, maxx-(xpad*4), ypad+offset, maxx-xpad, ypad+boxh+offset, xpad*4, ypad+boxh+offset)\nend\nsetDefaultFillColor(layer, Shape_Polygon, 255/255, 255/255 , 155/255, 155/255)\nlocal butw = xpad/2\nlocal divpos = maxx/2.3\nfor i=0,tbsize do\n    local offset = i*(boxh+ypad)\n    addQuad(layer, divpos, (ypad*2)+offset, divpos+butw, (ypad*2)+offset, divpos+butw+(xpad*3), boxh+offset, divpos+(xpad*3), boxh+offset)\nend\ndivpos = maxx-maxx/2.15\nfor i=0,tbsize do\n    local offset = i*(boxh+ypad)\n    addQuad(layer, divpos, (ypad*2)+offset, divpos+butw, (ypad*2)+offset, divpos+butw+(xpad*3), boxh+offset, divpos+(xpad*3), boxh+offset)\nend\ndivpos = maxx-maxx/3.4\nfor i=0,tbsize do\n    local offset = i*(boxh+ypad)\n    addQuad(layer, divpos, (ypad*2)+offset, divpos+butw, (ypad*2)+offset, divpos+butw+(xpad*3), boxh+offset, divpos+(xpad*3), boxh+offset)\nend\ndivpos = maxx-maxx/6-xpad\nfor i=0,tbsize do\n    local offset = i*(boxh+ypad)\n    addQuad(layer, divpos, (ypad*2)+offset, divpos+butw, (ypad*2)+offset, divpos+butw+(xpad*3), boxh+offset, divpos+(xpad*3), boxh+offset)\nend\ndivpos = maxx-maxx/6-(xpad*2)\nfor i=0,tbsize do\n    local offset = i*(boxh+ypad)\n    addQuad(layer, divpos, (ypad*2)+offset, divpos+butw, (ypad*2)+offset, divpos+butw+(xpad*3), boxh+offset, divpos+(xpad*3), boxh+offset)\nend\nsetDefaultFillColor(layer, Shape_Polygon, 255/255, 255/255 , 55/255, 200/255)\nlocal butw = maxx/6\nfor i=0,tbsize do\n    local action = \"done_\"..i+1\n    if (mode == MODE_EDIT) then action = \"edit_\"..i+1 end \n    if (mode == MODE_DELT) then action = \"delt_\"..i+1 end\n    if (GLOBAL_ACTION == action) then\n        setDefaultFillColor(layer, Shape_Polygon, 55/255, 55/255 , 255/255, 200/255)\n    else\n        setDefaultFillColor(layer, Shape_Polygon, 255/255, 255/255 , 55/255, 200/255)\n    end    \n    local offset = i*(boxh+ypad)\n    addQuad(layer, maxx-butw, (ypad*2)+offset, maxx-(xpad*4.5), (ypad*2)+offset, maxx-(xpad*2), boxh+offset, maxx-butw+(xpad*3), boxh+offset)\n    actionTbl[action] = { maxx-butw, (ypad*2)+offset, maxx-(xpad*2), boxh+offset }\nend\n\nlocal bottomline = maxy-boxh-(2*ypad)\ndivpos = maxx/3-xpad\nbutw = maxx/6\nif mode ~= MODE_READ then \n    local action = \"edit\"\n    if (mode == MODE_EDIT) then action = \"delete\" end \n    if (mode == MODE_DELT) then action = \"normal\" end\n    if (GLOBAL_ACTION == action) then\n        setDefaultFillColor(layer, Shape_Polygon, 55/255, 55/255 , 255/255, 200/255)\n    else\n        setDefaultFillColor(layer, Shape_Polygon, 255/255, 255/255 , 55/255, 200/255)\n    end\n    addQuad(layer, divpos, bottomline, divpos+butw, bottomline, divpos+butw+(xpad*3), boxh+bottomline, divpos+(xpad*3), boxh+bottomline)\n    actionTbl[action] = { divpos, bottomline, divpos+butw+(xpad*3), boxh+bottomline }\n    divpos = maxx/2+xpad\n    if (GLOBAL_ACTION == \"add\") then\n        setDefaultFillColor(layer, Shape_Polygon, 55/255, 55/255 , 255/255, 200/255)\n    else\n        setDefaultFillColor(layer, Shape_Polygon, 255/255, 255/255 , 55/255, 200/255)\n    end\n    addQuad(layer, divpos, bottomline, divpos+butw, bottomline, divpos+butw+(xpad*3), boxh+bottomline, divpos+(xpad*3), boxh+bottomline)\n    actionTbl[\"add\"] = { divpos, bottomline, divpos+butw+(xpad*3), boxh+bottomline }\nend\n\nif (pageNum > 1) then\n    divpos = maxx/12\n    if (GLOBAL_ACTION == \"prev\") then\n        setDefaultFillColor(layer, Shape_Polygon, 55/255, 55/255 , 255/255, 200/255)\n    else\n        setDefaultFillColor(layer, Shape_Polygon, 255/255, 255/255 , 55/255, 200/255)\n    end\n    addQuad(layer, divpos, bottomline, divpos+butw, bottomline, divpos+butw+(xpad*3), boxh+bottomline, divpos+(xpad*3), boxh+bottomline)\n    actionTbl[\"prev\"] = { divpos, bottomline, divpos+butw+(xpad*3), boxh+bottomline }\nend\nif (pageNum < maxPage) then\n    divpos = maxx-maxx/4\n    if (GLOBAL_ACTION == \"next\") then\n        setDefaultFillColor(layer, Shape_Polygon, 55/255, 55/255 , 255/255, 200/255)\n    else\n        setDefaultFillColor(layer, Shape_Polygon, 255/255, 255/255 , 55/255, 200/255)\n    end\n    addQuad(layer, divpos, bottomline, divpos+butw, bottomline, divpos+butw+(xpad*3), boxh+bottomline, divpos+(xpad*3), boxh+bottomline)\n    actionTbl[\"next\"] = { divpos, bottomline, divpos+butw+(xpad*3), boxh+bottomline }\nend\n\nsetDefaultFillColor(layer, Shape_Polygon, 10/255, 10/255 , 255/255, 255/255)\nfor i=0,tbsize do\n    local inCooldown = tonumber(tb[i+1][6])\n    if (inCooldown == 1) then\n        local offset = i*(boxh+ypad)\n        local icew = xpad\n        divpos = maxx/2.4\n        addTriangle(layer, divpos, (ypad*2)+offset, divpos+icew, (ypad*2)+offset, divpos+icew/2, boxh+offset-ypad)\n        divpos = maxx/2.44\n        addTriangle(layer, divpos, (ypad*2)+offset, divpos+icew, (ypad*2)+offset, divpos+icew/2, boxh+offset)\n    end\nend\n--text layer\nlayer = createLayer()\nsetDefaultFillColor(layer, Shape_Text, 255/255, 255/255 , 55/255, 255/255)\nlocal font = loadFont(\"RobotoCondensed\",boxh-(2*ypad))\nlocal text = \"name\"\nfor i=0,tbsize do\n    text = tb[i+1][2]\n    local offset = i*(boxh+ypad)\n    addText(layer, font, text, xpad*4, boxh-ypad+offset)\nend\n\nsetDefaultFillColor(layer, Shape_Text, 255/255, 255/255 , 255/255, 255/255)\nfont = loadFont(\"RobotoCondensed\",boxh-(3*ypad))\ntext = \"calib\"\nfor i=0,tbsize do\n    text = tb[i+1][3]\n    local offset = i*(boxh+ypad)\n    addText(layer, font, text, maxx/2.05, boxh-ypad+offset)\nend\ntext = \"XdXXhXXm\"\nlocal mfx,mfy = getTextBounds(font,text)\ntext = \"time\"\nfor i=0,tbsize do\n    text = tb[i+1][4]\n    local cfx,cfy = getTextBounds(font,text)\n    local offset = i*(boxh+ypad)\n    addText(layer, font, text, maxx-(maxx/2.4)+((mfx-cfx)/2), boxh-ypad+offset)\nend\nsetDefaultFillColor(layer, Shape_Text, 155/255, 155/255 , 155/255, 255/255)\ntext = \"theshold\"\nfor i=0,tbsize do\n    text = tostring(tb[i+1][5])\n    local offset = i*(boxh+ypad)\n    addText(layer, font, text, maxx-maxx/4.2, boxh-ypad+offset)\nend\nsetDefaultFillColor(layer, Shape_Text, 0, 0 , 0, 255/255)\ntext = \"Done\"\nif (mode == MODE_EDIT) then text = \"Edit\" end \nif (mode == MODE_DELT) then text = \"Delete\" end\nfor i=0,tbsize do\n    local offset = i*(boxh+ypad)\n    addText(layer, font, text, maxx-maxx/8, boxh-ypad+offset)\nend\n\nif mode ~= MODE_READ then \n    text = \"Mode: Norm\" -- edit\n    if (mode == MODE_EDIT) then text = \"Mode: Edit\" end --delete\n    if (mode == MODE_DELT) then text = \"Mode: Delete\" end --normal\n    addText(layer, font, text, (maxx/2.8), maxy-(4*ypad))\n    text = \"Add\"\n    addText(layer, font, text, (maxx/1.7), maxy-(4*ypad))\nend\n\nif (pageNum > 1) then\n    text = \"Prev\"\n    addText(layer, font, text, maxx/6.5, maxy-(4*ypad))\nend\nif (pageNum < maxPage) then\n    text = \"Next\"\n    addText(layer, font, text, maxx-maxx/5.5, maxy-(4*ypad))\nend\n\nif (getCursorReleased()) then \n    GLOBAL_ACTION = ''\nend\nif (LAST_CLICK ~= newTimestamp) then\n    setOutput('')   \nend    \nif (getCursorPressed()) then \n    local action = findAction(actionTbl)\n    GLOBAL_ACTION = action\n    setOutput(action)\n    if (action ~= '') then\n        logMessage(\"Action \"..action)\n    end\n    LAST_CLICK = newTimestamp\nend\n\nrequestAnimationFrame(1)\n\nif false then\n    local layer = createLayer()\n    local font = loadFont('Play-Bold', 14)\n    setNextFillColor(layer, 1, 1, 1, 1)\n    addText(layer, font, string.format('render cost : %d / %d', getRenderCost(), getRenderCostMax()), 8, 16)\nend]]\nend    ","filter":{"args":[],"signature":"start()","slotKey":"-2"},"key":"3"},{"code":"system.print('Text input: '..text)\nlocal lowerText = text:lower()\nif (startsWith(lowerText,'addall')) then\n    system.print('Add All Lua Action')\n    local input = text:sub(7,#text)\n    entries:updateEntriesByName(input)\n    entries:saveTo(bank)\n    entries:refresh('Lua Add All',true)\n    return\nend    \nif (startsWith(lowerText,'add')) then\n    system.print('Add Lua Action')\n    local input = text:sub(4,#text)\n    local inputVals = split(input,SEP)\n    local inputSize = #inputVals\n    if (inputSize < 1) then\n        system.print(\"Please enter the required parameters\")\n        return\n    end\n    local name = string.gsub(inputVals[1], '^%s*(.-)%s*$', '%1')\n    local timestamp = system.getTime()\n    if (inputSize >= 2) then\n        timestamp = getTimestampFromStr(inputVals[2])\n    end\n    local origCal = '100'\n    if (inputSize >= 3) then\n        origCal = inputVals[3]\n    end\n    local threshold = tostring(GLOBAL_THRESHOLD)\n    if (inputSize >= 4) then\n        threshold = inputVals[4]\n    end\n    system.print(name .. \" \" .. timestamp .. \" \" .. origCal .. \" \" .. threshold)\n    local entry = entries:update(0,name,timestamp,origCal,threshold)\n    entry:save(bank)\n    entries:refresh('Lua Add',true)\nend\n\nif (startsWith(lowerText,'edit')) then\n    system.print('Edit Lua Action')\n    if (entries.mode == MODE_EDIT and entries.editpos ~= nil) then\n        local entry = entries.entries[entries.editpos]\n        system.print(\"editing \".. entry.name)\n        local input = text:sub(5,#text)\n        local inputVals = split(input,SEP)\n        local inputSize = #inputVals\n        if (inputSize < 1) then\n            system.print(\"Please enter the required parameters\")\n            return\n        end\n        local timestamp = system.getTime()\n        if (inputSize >= 1) then\n            timestamp = getTimestampFromStr(inputVals[1])\n        end\n        local origCal = '100'\n        if (inputSize >= 2) then\n            origCal = inputVals[2]\n        end\n        local threshold = tostring(GLOBAL_THRESHOLD)\n        if (inputSize >= 3) then\n            threshold = inputVals[3]\n        end\n        system.print(entry.name .. \" \" .. timestamp .. \" \" .. origCal .. \" \" .. threshold)\n        local entry = entries:update(entries.editpos,entry.name,timestamp,origCal,threshold)\n        entries.editpos = nil\n        entry:save(bank)\n        entries:refresh('Lua Edit',true)\n    else\n        system.print(\"Select which entry you wish to edit first in edit mode.\")\n    end    \nend\n\nif (startsWith(lowerText,'y')) then\n    system.print('Confirmed Lua Action')\n    if (entries.mode == MODE_DELT and entries.delpos ~= nil) then\n        local delentry = entries.entries[entries.delpos]\n        system.print(\"deleting \".. delentry.name)\n        table.remove(entries.entries,entries.delpos)\n        bank.clear()\n        for i,entry in ipairs(entries.entries) do\n            entry.pos = i\n            entry:save(bank)\n        end\n        entries:refresh('Lua confirm')\n        entries.delpos = nil\n    end    \nend\n\nif (startsWith(lowerText,'n')) then\n    system.print('Cancelled Lua Action')\n    entries.delpos = nil\nend","filter":{"args":[{"variable":"*"}],"signature":"inputText(text)","slotKey":"-2"},"key":"4"}],"methods":[],"events":[]}
